#!/usr/lib/sagemath/sage -python
import sys
from sage.all import *


"""
Babai algorithm for solving Closest Vector Problem-CVP

 AUTHORS:

 K.Draziotis (26-5-2014): initial version



 TESTS: 


 REFERENCES:
 
"""


#*****************************************************************************
#       Copyright (C) 2014 K.Draziotis <drazioti@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

r"""
    Construct a meet semi-lattice from various forms of input data.

    INPUT:

    - ``data``, ``*args``, ``**options`` -- data and options that will
      be passed down to :func:`Poset` to construct a poset that is
      also a meet semilattice.

    .. seealso:: :func:`Poset`, :func:`JoinSemilattice`, :func:`LatticePoset`

    EXAMPLES:

    Using data that defines a poset::

          sage: MeetSemilattice([[1,2],[3],[3]])
          Finite meet-semilattice containing 4 elements

          sage: MeetSemilattice([[1,2],[3],[3]], cover_relations = True)
          Finite meet-semilattice containing 4 elements

    Using a previously constructed poset::

          sage: P = Poset([[1,2],[3],[3]])
          sage: L = MeetSemilattice(P); L
          Finite meet-semilattice containing 4 elements
          sage: type(L)
          <class 'sage.combinat.posets.lattices.FiniteMeetSemilattice_with_category'>

    If the data is not a lattice, then an error is raised::

          sage: elms = [1,2,3,4,5,6,7]
          sage: rels = [[1,2],[3,4],[4,5],[2,5]]
          sage: MeetSemilattice((elms, rels))
          Traceback (most recent call last):
          ...
          ValueError: Not a meet semilattice.
    """
if sys.argv[1]=="1":
  if len(sys.argv) != 3:
     print "Usage : %s foo,(where the text file foo contains two lines the first is a matrix of the form [[   ],...,[   ]] and the second is the target vector of the form [   ]. Note that there must be a blank line between the matrix and the target vector. "%sys.argv[0];
     print "Outputs, the closest vector to target vector of the lattice generated by the rows of M, using Babai's algorithm."
     sys.exit(1)
  print sys.argv[2]
  f=open(sys.argv[2])
  a1=f.readline()
  f.readline()
  b1=f.readline()
  M3=matrix(sage_eval(a1));
  rank=int(M3.nrows());
  dim=int(M3.ncols());
  if rank>dim:
    print "Error : linear dependent vectors"
  r=[];
  L=[];
  Y=[];
  babai=[];
  target=vector(sage_eval(b1));
  f.close
if sys.argv[1]=="0":
  if len(sys.argv) != 4:
    print "Usage: %s <matrix> <targer vector>"%sys.argv[0];
    print "Outputs the closest vector to target_vector of the lattice generated by the rows of M, using Babai's algorithm."
    sys.exit(1)
  M3=matrix(sage_eval(sys.argv[2]));
  rank=int(M3.nrows());
  dim=int(M3.ncols());
  if rank>dim:
    print "Error : linear dependent vectors"
    sys.exit(1)
  r=[];
  L=[];
  Y=[];
  babai=[];
  target=vector(sage_eval(sys.argv[3]));
if sys.argv[1]!="0" and sys.argv[1]!="1":
  print "Usage : %s x foo, where x is equals to 1 if your inpout is from a file, or 0 if not, and foo is either a text file or a mtrix with a vector. "%sys.argv[0];
  sys.exit(1)
w=vector([0 for i in range(0,dim)]);
##########
#  First step. We reduce the rowspace of A with LLL and delta = 3/4
##########
AA=M3.LLL(delta=0.75,algorithm='NTL:LLL');
##########
#  Second step. Apply Babai to the reduced basis
##########
GM=AA.gram_schmidt()[0];
w=target
j=0;
i=0;
for j in range(rank):
    i=rank-j-1
    a=w.dot_product((GM[i]));
    bb=vector(GM[i]).dot_product(GM[i]);
    L=a/bb;
    Y.append(floor(L+.5)*AA.row(i));
    w=w-(L-floor(L+.5))*GM[i]-floor(L+.5)*AA.row(i);
babai=sum(Y);
print(babai);
sum(Integer((babai[i]-target[i]))^2 for i in range(dim));

