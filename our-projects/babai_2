#!/usr/lib/sagemath/sage -python
import sys
from sage.all import *

"""
Babai algorithm for solving Closest Vector Problem-CVP

 AUTHORS:

 K.Draziotis (26-5-2014): initial version

 TESTS:


 REFERENCES:
 
"""

#*****************************************************************************
#       Copyright (C) 2014 K.Draziotis <drazioti@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

if len(sys.argv) != 2:
    print "Usage : %s foo,(where the text file foo contains two lines the first is a matrix in the form [[   ],...,[   ]] and the second is the target vector in the form [   ] "%sys.argv[0];
    print "Outputs the closest vector to target vector of the lattice generated by the rows of M, using Babai's algorithm."
    sys.exit(1)
f=open(sys.argv[1])
a1=f.readline()
f.readline()
b1=f.readline()
M3=matrix(sage_eval(a1));
rank=int(M3.nrows());
dim=int(M3.ncols());
w=vector([0 for i in range(0,dim)]);
r=[];
L=[];
Y=[];
babai=[];
target=vector(sage_eval(b1));
f.close
##########
#  First step. We reduce the rowspace of A with LLL and delta = 3/4
##########
AA=M3.LLL(delta=0.75,algorithm='NTL:LLL');
##########
#  Second step. Apply Babai to the reduced basis
##########
GM=AA.gram_schmidt()[0];
w=target
j=0;
i=0;
for j in range(rank):
    i=rank-j-1
    a=w.dot_product((GM[i]));
    bb=vector(GM[i]).dot_product(GM[i]);
    L=a/bb;
    Y.append(floor(L+.5)*AA.row(i));
    w=w-(L-floor(L+.5))*GM[i]-floor(L+.5)*AA.row(i);
babai=sum(Y);
print(babai);
sum(Integer((babai[i]-target[i]))^2 for i in range(dim));

